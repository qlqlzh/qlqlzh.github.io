아래 코드들이 실행되면 오른쪽 상단에는 실행시간, 중단에는 9x9빈칸, 그리그 그 아래에는 Start, Quit버튼이 위치된다.

![1](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEg4gCPVZaSpREOn_Rc8bBnPxmucxI6--ooAKWpNRWcyCgItRDBOMbYNYGSj7I_Hm3GVyfvu2Ne0lWYHju-EbH3vgFPNBh_7MeHTGO2Jg9UAvp7hh28Lm9_fBcdvSzpI9XgOyNWp9-4vr8mCyVYL489wlNA_CsweFdedEljHpNmLs50RN8q8n-VASyA-ABim/w626-h640/1.png){: width="100%" height="100%"}

하나의 9X9 사각형을 9개의 3X3사각형으로 나누는 선을 아래 코드로 이용해 그린다. 

```js
sudoku_easy.jsp
...
<script type="text/javascript">
	...
	
	$(document).ready(function() 
	{
		...	    
	    //3x3의 작은 사각형으로 나누는 선 그리기
		var row_add;
		var col_add;
	    for(var i=2; i< 8; i+=3)
	    {
	        for(var j=0; j<9; j++)
	        {
	        	row_add = "#"
	        	col_add = "#"     
	       		row_add += (i+j*9);
	       		col_add += (i*9+j);
	       		//border-left: double 3px blue;
	        	$(row_add).css("border-right","4px solid black");
	        	$(col_add).css("border-bottom","4px solid black");
	        }  
	    }
	});
	...
</script>
```

![2](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjYFvkz2jChTcJRIQo9GIhj0JN1fdbb7vOKafGXwOekf3HRw6sShv22XnJF8G4V_ihOpCQol72JPwNRRxu1sclp_F-avPn5wfyZ8YZJH9MxJjwyRgfs9pZkLnuXwVRherS7qjoC8ITp0s6AjigGHsuYn7RYeKKR8wHgPUzvRfut3UIoCP8mCj1XVm_00Hzc/w640-h406/2.png){: width="100%" height="100%"}

Start버튼을 누르면 sciprt태그 의  start 함수가 실행된다.

```jsp
sudoku_easy.jsp
...
<script type="text/javascript">
	...
	function start() 
	{			
		sudoku_maker();		
		...
	}
	...
</script>	
```

start함수에서 sudoku_maker함수가 실행되고, sudoku_maker클래스의 객체가 생성된다.

![3](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEiO6kLEXzmzg_Pncdl97Bc3doGn05F7e4gimNVub9vpDNSe2TDGqSo5R0MiuXpmNUewVX1fSiyIJQ7Piz7mzzRNVZgHtDhubGi_aKeQbdhbx5LG-M2lqG7xtLaW1M9AMu1e9vlrPGypab8KNZhqkYGnaA5NzFCBa7dct9nqucYjigEXgHMxLTl-BXAZX4Gc/w640-h280/3.png){: width="100%" height="100%"}

```java
package games;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Random;
import java.util.TreeMap;


public class sudoku_maker 
{
	int cur_idx;
	int cur_num;
	Random rand = new Random();
	ArrayList<Integer> nums;
	ArrayList<Integer> including;
	ArrayList<Integer> total = new ArrayList<Integer>();
	ArrayList<ArrayList<Integer>> board =new ArrayList<ArrayList<Integer>>();
	ArrayList<ArrayList<Integer>> rows = new ArrayList<ArrayList<Integer>>();;
	ArrayList<ArrayList<Integer>> cols = new ArrayList<ArrayList<Integer>>();
	ArrayList<ArrayList<Integer>> small_boards =new ArrayList<ArrayList<Integer>>();
	TreeMap<Integer,Integer> blank = new TreeMap<Integer,Integer>();
	
	long beforeTime; 
	long afterTime;
	long secDiffTime;
	long beforeTime_o; 
	long afterTime_o;
	long secDiffTime_o;	
	boolean stop = false;
	boolean back = false;

	public sudoku_maker(int blank_size)
	{		
		initializer();	
        ...
	}
    ...
}
```

initializer함수를 이용해 2차원 어레이리스트 board,row,cols,small_boards들의 모든 요소값들을 -1로 만둘어 준다.

```java
public class sudoku_maker 
{
	...
	public void initializer()
	{
		total = new ArrayList<Integer>();
		board =new ArrayList<ArrayList<Integer>>();
		rows = new ArrayList<ArrayList<Integer>>();;
		cols = new ArrayList<ArrayList<Integer>>();
		small_boards =new ArrayList<ArrayList<Integer>>();		
		for(int i=0; i<9; i++)
		{
			board.add(new ArrayList<>(Arrays.asList(-1,-1,-1,-1,-1,-1,-1,-1,-1)));
			rows.add(new ArrayList<>(Arrays.asList(-1,-1,-1,-1,-1,-1,-1,-1,-1)));
			cols.add(new ArrayList<>(Arrays.asList(-1,-1,-1,-1,-1,-1,-1,-1,-1)));
			small_boards.add(new ArrayList<>(Arrays.asList(-1,-1,-1,-1,-1,-1,-1,-1,-1)));
			for(int j=0; j<9; j++)
			{
				total.add(j+i*9);
			}
		 }
	  }
     ...
}	
```

processing함수를 이용해 스도쿠 판을 채워줄 숫자를 규칙에 맞게 배열한다.

```
public class sudoku_maker 
{
	...
	public sudoku_maker(int blank_size)
	{	
    	...
		processing();
        ...
	}
    ...
}
```

n_mix함수를 이용해 1~9까지 숫자를 무작위 순서로 배치한 어레이리스트를 받는다.

```java
public class sudoku_maker 
{
	public void processing()
	{
		//초기 세팅
		for(int i=0; i<9; i++)
		{			
			outerloop:
			while(true)
			{
				nums=n_mix(true);
				...
			}
		}			
	}
}
```

```java
public class sudoku_maker 
{
	...
	//9개의 숫자 무작위로 배치하기
	private ArrayList<Integer> n_mix(boolean init) 
	{
		ArrayList<Integer> n_array;
		if(init)
		{
			 n_array = new ArrayList<Integer>(Arrays.asList(1,2,3,4,5,6,7,8,9));
		}
		else
		{
			 n_array = new ArrayList<Integer>(Arrays.asList(0,1,2,3,4,5,6,7,8));
		}
		ArrayList<Integer> n_mix = new ArrayList<Integer>();
		int arr_size = 9;
		for(int i=0; i<9; i++)
		{
			int cur_idx = rand.nextInt(arr_size);		
			int cur_val = n_array.get(cur_idx);
			n_mix.add(cur_val);
			n_array.remove(Integer.valueOf(cur_val));
			arr_size -=1;
		}		
		return n_mix;	
	}
}
```

스도쿠에 배치된 숫자는 아래와 같은 규칙을 따른다.

1.각각의 가로줄(row)과 세로줄(column)에 1~9가 중복 없이 하나씩 들어간다. 

2.3×3칸(box) 안에는 1~9가 중복 없이 하나씩 들어간다.

예시를 가지고 위의 규칙하에 숫자를 배치하는 코드의 동작을 이해해보자.

첫번째 줄에 숫자를 넣는것은 특별히 고려해야할 것이 없음으로, 두번째 줄에 숫자를 넣는 상황부터 설명해 보겠다.

![4](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjC0ILi5mdAxy6xxzQimFwgGozjboMOJhrAqD01Qwlji5yxAtCzA3Z1INvzckeTNCq_2_TdujOovHYZVPNYBi4o1zEmR1k9FsZ74FOoF6YHd3MpXjeRT93xdDjUqvQRdqCbd0wReSvAywx3-CN8w-rTWiZEFaEc2nbwoLqR9nXPmQ0Nhtxy4_eubQbiSggW/w640-h516/5.png){: width="100%" height="100%"}

```
[ 4,  5,  2,  7,  3,  9,  8,  1,  6]
[ 8,  7,  3,  6,  5,  1,  9,  2,  4]
[-1, -1, -1, -1, -1, -1, -1, -1, -1]
[-1, -1, -1, -1, -1, -1, -1, -1, -1]
[-1, -1, -1, -1, -1, -1, -1, -1, -1]
[-1, -1, -1, -1, -1, -1, -1, -1, -1]
[-1, -1, -1, -1, -1, -1, -1, -1, -1]
[-1, -1, -1, -1, -1, -1, -1, -1, -1]
[-1, -1, -1, -1, -1, -1, -1, -1, -1]
```

```
두번째 줄에 넣을 숫자들을 얻어온다.
nums=n_mix(true);	// nums == [8, 7, 3, 6, 5, 1, 9, 2, 4]
두번재 행 첫번째 열에 들어갈 숫자cur_num(=nums.get(0))가 스도쿠 규칙에
적합한 값인지 판단한다.

board의 첫번째 열(=cols.get(0))에는 [-1,-1,-1, 4,-1,-1,-1,-1,-1]가 들어가 있다.
그리고 첫번째 3x3box(=small_boards.get(0))에는 [-1, 2, -1, 4, 5,-1,-1,-1,-1]가 들어있다.
cur_num(=8)이 cols.get(0)과 small_boards.get(0)에 들어있지 않으므로, 8은 이 두배열에
들어갈 수 있다. 

두번째 행의 들어갈 나머지 숫자들(nums.get(1)~nums.get(8))에대해 앞서 살펴본 방법과 
동일한 방식으로 판단한다. 

nums의 모든 숫자들이 위의 조건을 만족했음으로, 아래의 반복문(화살표로 표시된 영역)을
이용해 rows, cols, small_boards, board에 nums값들을 넣어준다.
```

```
public class sudoku_maker 
{
	public void processing()
	{
		//초기 세팅
		for(int i=0; i<9; i++)
		{			
			outerloop:
			while(true)
			{
				...
				for(int j=0; j<9; j++)
				{							
					cur_num = nums.get(j);			
					
					//자리가 비어있고, 이미 사용된 숫자가 아닌지 판별한다.
					if(cols.get(j).indexOf(cur_num) <0)
					{
						if(small_boards.get(j/3 + 3*Integer.valueOf(i / 3)).indexOf(cur_num) <0)
						{
							if(j==8)
							{										
△								for(int k=0; k<9; k++)
여								{	
기									cur_num = nums.get(k);	
가 									rows.get(i).set(k, cur_num);
실									cols.get(k).set(i, cur_num);
행									small_boards.get(k/3 + 3*(i / 3)).set(cur_num-1, cur_num);
됨								    board.get(i).set(k, cur_num);									
▽								}	
								break outerloop;								
							}							
						}
						else
						{		
							...
						}	
					}
					else
					{
						...
					}						
				}

			}
		}			
	}
}
```

![5](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhW4bDxOPjM15Ky_AO7t5tIuIBvEOAlEimoMMXCfGkzsNpeAgy9ctg8HmlRQW7bWXebYon-LbAzMeu5Njs89Pml6l_7z-HXIIyGJ8mVyVjbLX6l-YI1VwlRZk0nq7uVxGCX46uGeJGzk9ks39VvfxjCBZIJH8hhruQxAvB3cO8F4UHJGxF3130sKmdj2zmD/w640-h516/5.png){: width="100%" height="100%"}

```
세번째 줄에 넣을 숫자들을 얻어온다.
nums=n_mix(true);	// nums == [9, 6, 2, 4, 1, 8, 7, 5, 3]
두번재 행 두번재 열에 들어갈 숫자cur_num(=nums.get(2))가 cols.get(2)
(=[-1, 2, 3, -1, -1, -1, -1, -1, -1])에 들어있으므로 backtracking
(별로 표시한 부분, 이 때 i=2, j=2)를 실행한다. 
```

```java
public class sudoku_maker 
{
	public void processing()
	{
		//초기 세팅
		for(int i=0; i<9; i++)
		{			
			outerloop:
			while(true)
			{
				nums=n_mix(true);
				innerloop:
				for(int j=0; j<9; j++)
				{							
					cur_num = nums.get(j);			
					
					//자리가 비어있고, 이미 사용된 숫자가 아닌지 판별한다.
					if(cols.get(j).indexOf(cur_num) <0)
					{
						if(small_boards.get(j/3 + 3*Integer.valueOf(i / 3)).indexOf(cur_num) <0)
						{
							...					
						}
						else
						{		
							i = backtracking(i, j);		
							break innerloop;
						}	
					}
					else
					{
★					   i =backtracking(i, j);	//i=2, j=2
						break innerloop;
					}						
				}

			}
		}			
	}
}
```

```java
public class sudoku_maker 
{	
    ...
    public int backtracking(int i, int j)
	{
		//i=2, j=2
		including = new ArrayList<Integer>(Arrays.asList(1,2,3,4,5,6,7,8,9)); 
		including.removeAll(rows.get(i));						//=> including = [1,2,3,4,5,6,7,8,9]
		including.removeAll(cols.get(j));						//=> including = [1,4,5,6,7,8,9]
		including.removeAll(small_boards.get(j/3 + 3*(i / 3)));	//=> including = [1,6,9]	
        
		//board의 i행 j열에 들어갈 수 있는 숫자가 하나도 없는경우
		if(including.size() == 0)
		{	
			nums = new ArrayList<>(rows.get(i-1));		
			if(i > 0)
			{
				rows.set(i-1, new ArrayList<>(Arrays.asList(-1,-1,-1,-1,-1,-1,-1,-1,-1)));
				board.set(i-1, new ArrayList<>(Arrays.asList(-1,-1,-1,-1,-1,-1,-1,-1,-1)));
				for(int k=0; k<9; k++)
				{	
					cols.get(k).set(i-1, -1);
					cur_num = nums.get(k);	
					small_boards.get(k/3 + 3*Integer.valueOf((i-1) / 3)).set(cur_num-1, -1);									
				}							
				return i-1;
			}
			else
			{
				return 0;
			}

		}
        
		//board의 i행 j열에 들어갈 수 있는 숫자가 하나 이상(1,6,9) 있는경우  
		else
		{
			return i;
		}
	}
    ...
}
```

processing()에서 'i =backtracking(i(=2), j(=2));'수행결과 'i = i'가 실행된다.

```

```

